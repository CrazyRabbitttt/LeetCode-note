
### HTTPS 
[è¿™é‡Œæ˜¯é“¾æ¥](https://www.nowcoder.com/discuss/1009213)


### Muduoä¸­ä¼˜ç§€æ€æƒ³åˆ†æåœ°å€
[è¿™é‡Œæ˜¯é“¾æ¥](https://zhuanlan.zhihu.com/p/495016351)

æœ€åéƒ¨åˆ†æœ‰å¯¹äºRunInloopçš„åˆ†æ



## æ“ä½œç³»ç»Ÿ

#### å†…æ ¸æ€ç”¨æˆ·æ€çš„åˆ‡æ¢
https://blog.csdn.net/qq_40276626/article/details/119979930

### 5ç§IOæ¨¡å‹ï¼Œå¾ˆå¥½çš„æ–‡ç« 
> [é“¾æ¥åœ¨è¿™é‡Œ](https://zhuanlan.zhihu.com/p/115912936)

> é˜»å¡ä¸ºä»€ä¹ˆä¼šå¾ˆæ¶ˆè€—èµ„æºå‘¢ï¼Ÿ

é˜»å¡è™½ç„¶æ˜¯ä¸æ¶ˆè€—CPUï¼Œä½†æ˜¯æ—¢ç„¶é˜»å¡äº†å°±ä¼šè®©å‡ºæ¥CPUç»™åˆ«çš„è¿›ç¨‹/çº¿ç¨‹ï¼Œè¿™ä¸ªåˆ‡æ¢çš„æ¶ˆè€—æ˜¯æ¯”è¾ƒé«˜çš„
è€Œéé˜»å¡å°±ä¸ä¼šè¿›è¡Œåˆ‡æ¢, ä½†æ˜¯è½®è¯¢

### æŒ‡é’ˆå’Œå¼•ç”¨çš„åŒºåˆ«
[link](https://github.com/guaguaupup/cpp_interview/blob/main/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%E2%80%94C++.md#%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB)

> - åº•å±‚æ±‡ç¼–çš„å®ç°çš„è¯ï¼Œå¼•ç”¨å°±æ˜¯ä¸€ä¸ªå¸¸é‡æŒ‡é’ˆ
> - åœ¨C++ä¸­ï¼ŒæŒ‡é’ˆå’Œå¼•ç”¨ç»å¸¸ç”¨äºå‡½æ•°çš„å‚æ•°ä¼ é€’ï¼Œç„¶è€Œï¼ŒæŒ‡é’ˆä¼ é€’å‚æ•°å’Œå¼•ç”¨ä¼ é€’å‚æ•°æ˜¯æœ‰æœ¬è´¨ä¸Šçš„ä¸åŒçš„ï¼šæŒ‡é’ˆä¼ é€’å‚æ•°æœ¬è´¨ä¸Šæ˜¯å€¼ä¼ é€’çš„æ–¹å¼ï¼Œå®ƒæ‰€ä¼ é€’çš„æ˜¯ä¸€ä¸ªåœ°å€å€¼ã€‚å€¼ä¼ é€’çš„ç‰¹ç‚¹æ˜¯è¢«è°ƒå‡½æ•°å¯¹å½¢å¼å‚æ•°çš„ä»»ä½•æ“ä½œéƒ½æ˜¯ä½œä¸ºå±€éƒ¨å˜é‡è¿›è¡Œï¼Œä¸ä¼šå½±å“ä¸»è°ƒå‡½æ•°çš„å®å‚å˜é‡çš„å€¼ã€‚è€Œåœ¨å¼•ç”¨ä¼ é€’è¿‡ç¨‹ä¸­ï¼Œ è¢«è°ƒå‡½æ•°çš„å½¢å‚è™½ç„¶ä¹Ÿä½œä¸ºå±€éƒ¨å˜é‡åœ¨æ ˆä¸­å¼€è¾Ÿäº†å†…å­˜ç©ºé—´ï¼Œä½†æ˜¯è¿™æ—¶å­˜æ”¾çš„æ˜¯ç”±ä¸»è°ƒå‡½æ•°æ”¾è¿›æ¥çš„å®å‚å˜é‡çš„åœ°å€ï¼ˆæŒ‡é’ˆæ”¾çš„æ˜¯å®å‚å˜é‡åœ°å€çš„å‰¯æœ¬ï¼‰ã€‚


### å³å€¼å¼•ç”¨ä¸move
[link](https://github.com/guaguaupup/cpp_interview/blob/main/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%E2%80%94C++.md#%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB)

- æ™®é€šçš„å·¦å€¼æ˜¯å¦ä¹Ÿèƒ½å€ŸåŠ©ç§»åŠ¨è¯­ä¹‰æ¥ä¼˜åŒ–æ€§èƒ½å‘¢ï¼ŸC++11ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œæä¾›äº†std::moveæ–¹æ³•æ¥å°†å·¦å€¼è½¬æ¢ä¸ºå³å€¼ï¼Œä»è€Œæ–¹ä¾¿åº”ç”¨ç§»åŠ¨è¯­ä¹‰ã€‚moveæ˜¯å°†å¯¹è±¡èµ„æºçš„æ‰€æœ‰æƒä»ä¸€ä¸ªå¯¹è±¡è½¬ç§»åˆ°å¦ä¸€ä¸ªå¯¹è±¡ï¼Œåªæ˜¯è½¬ç§»ï¼Œæ²¡æœ‰å†…å­˜çš„æ‹·è´ï¼Œè¿™å°±æ˜¯æ‰€è°“çš„moveè¯­ä¹‰ã€‚ moveå®é™…ä¸Šå®ƒå¹¶ä¸èƒ½ç§»åŠ¨ä»»ä½•ä¸œè¥¿ï¼Œå®ƒå”¯ä¸€çš„åŠŸèƒ½æ˜¯å°†ä¸€ä¸ªå·¦å€¼å¼ºåˆ¶è½¬æ¢ä¸ºä¸€ä¸ªå³å€¼å¼•ç”¨, ç„¶åè½¬ç§»äº†èµ„æºçš„æ‰€æœ‰æƒ
- åœ¨MyStringç±»ä¸­æ˜¯æ·±æ‹·è´ï¼Œä½†æ˜¯å¦‚æœä¼ é€’çš„æ˜¯"hahahah"ï¼šä¸€ä¸ªå³å€¼ï¼Œé‚£ä¹ˆæ·±æ‹·è´å¤ªæµªè´¹äº†ï¼Œæ‰€ä»¥å¯ä»¥é‡è½½ä¸€ä¸ªä¼ é€’å³å€¼å¼•ç”¨çš„å‚æ•° (MyString && m)


### é‡è½½ä¸ extern C
[è¿™é‡Œæ˜¯é“¾æ¥](https://www.nowcoder.com/discuss/1025870)

### è™šå‡½æ•°é—®é¢˜
[link](https://github.com/guaguaupup/cpp_interview/blob/main/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%E2%80%94C++.md#c%E8%99%9A%E5%87%BD%E6%95%B0)

### å¼ºåˆ¶ç±»å‹è½¬æ¢
[link](https://github.com/guaguaupup/cpp_interview/blob/main/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%E2%80%94C++.md#c-%E5%9B%9B%E7%A7%8D%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2)


### å†…å­˜æ³„æ¼
[link](https://github.com/guaguaupup/cpp_interview/blob/main/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%E2%80%94C++.md#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%87%BA%E7%8E%B0%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95)


### C++11
[link](https://github.com/guaguaupup/cpp_interview/blob/main/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%E2%80%94C++.md#watermelonc11%E6%96%B0%E7%89%B9%E6%80%A7)

### æ™ºèƒ½æŒ‡é’ˆ
[link](https://aijishu.com/a/1060000000286819)

> - unique_ptr ä¸€èˆ¬æ˜¯ä¸éœ€è¦å¤šä¸ªæŒ‡å‘åŒä¸€ä¸ªå¯¹è±¡çš„æŒ‡é’ˆæ—¶ä½¿ç”¨ï¼Œå¯¹è±¡æˆ–æ–¹æ³•å†…éƒ¨ä½¿ç”¨æ—¶ä¼˜å…ˆä½¿ç”¨unique_ptr 
> - shared_pträ¸€èˆ¬åœ¨éœ€è¦å¤šä¸ªæ‰§è¡ŒåŒä¸€ä¸ªå¯¹è±¡çš„æŒ‡é’ˆä½¿ç”¨ã€‚åœ¨æˆ‘çœ‹æ¥å¯ä»¥ç®€å•çš„ç†è§£ï¼šè¿™ä¸ªå¯¹è±¡éœ€è¦è¢«å¤šä¸ª Class åŒæ—¶ä½¿ç”¨çš„æ—¶å€™ã€‚

### shared_ptrå¾ªç¯å¼•ç”¨é—®é¢˜
```cpp

struct A {
  shared_ptr<B> b;
};

struct B {
  shared_ptr<A> a;
};

shared_ptr<A> pa = make_shared<A>();
shared_ptr<B> pb = make_shared<B>();

pa->b = pb;
pb->a = pa;

```
> ç”¨weak_ptr è§£é™¤å¾ªç¯å¼•ç”¨é—®é¢˜


### C++å•ä¾‹æ¨¡å¼
> ä¸€èˆ¬é‡åˆ°çš„å†™è¿›ç¨‹æ± ç±»ã€æ—¥å¿—ç±»ã€å†…å­˜æ± ï¼ˆç¼“å­˜æ•°æ®çš„ç»“æ„ï¼Œä¸€å¤„å†™å¤šå‡ºè¯»æˆ–è€…å¤šå¤„å†™å¤šå¤„è¯»ï¼‰ç”¨åˆ°å•ä¾‹æ¨¡å¼
> **å®ç°æ–¹æ³•ï¼š**å…¨å±€åªæœ‰ä¸€ä¸ªå®ä¾‹ä¹Ÿå°±æ„å‘³ç€ä¸èƒ½ç”¨newè°ƒç”¨æ„é€ å‡½æ•°æ¥åˆ›å»ºå¯¹è±¡ï¼Œå› æ­¤æ„é€ å‡½æ•°å¿…é¡»æ˜¯è™šæœ‰çš„ã€‚ä½†æ˜¯ç”±äºä¸èƒ½newå‡ºå¯¹è±¡ï¼Œæ‰€ä»¥ç±»çš„å†…éƒ¨å¿…é¡»æä¾›ä¸€ä¸ªå‡½æ•°æ¥è·å–å¯¹è±¡ï¼Œè€Œä¸”ç”±äºä¸èƒ½å¤–éƒ¨æ„é€ å¯¹è±¡ï¼Œå› æ­¤è¿™ä¸ªå‡½æ•°ä¸èƒ½æ˜¯é€šè¿‡å¯¹è±¡è°ƒå‡ºæ¥ï¼Œæ¢å¥è¯è¯´è¿™ä¸ªå‡½æ•°åº”è¯¥æ˜¯å±äºå¯¹è±¡çš„ï¼Œå¾ˆè‡ªç„¶æˆ‘ä»¬å°±æƒ³åˆ°äº†ç”¨staticã€‚ç”±äºé™æ€æˆå‘˜å‡½æ•°å±äºæ•´ä¸ªç±»ï¼Œåœ¨ç±»å®ä¾‹åŒ–å¯¹è±¡ä¹‹å‰å°±å·²ç»åˆ†é…äº†ç©ºé—´ï¼Œè€Œç±»çš„éé™æ€æˆå‘˜å‡½æ•°å¿…é¡»åœ¨ç±»å®ä¾‹åŒ–åæ‰èƒ½æœ‰å†…å­˜ç©ºé—´ã€‚


** è¦ç‚¹æ€»ç»“**
> - å…¨å±€åªæœ‰ä¸€ä¸ªå®ä¾‹ã€ä½¿ç”¨static è¿›è¡Œè®¾è®¡ã€æ„é€ å‡½æ•°ä¸ºç§æœ‰ï¼ˆä¸èƒ½ä½¿ç”¨newåˆ›å»ºï¼‰
> - é€šè¿‡å…¬ç”¨çš„æ¥å£è·å¾—
> - çº¿ç¨‹å®‰å…¨
> - ç¦æ­¢æ‹·è´ or èµ‹å€¼


### æ‡’æ±‰å•ä¾‹è®¾è®¡æ¨¡å¼
- æ™®é€šçš„æ‡’æ±‰å¼çº¿ç¨‹ä¸å®‰å…¨
> ä¸åŠ é”çº¿ç¨‹å¹¶å‘äº§ç”Ÿå¤šä¸ªå®ä¾‹

```cpp
#include <iostream>
#include <mutex>
#include <pthread.h>

using namespace std;


class SingleInstance {
 public:
    
    static SingleInstance* GetInstance();

    // é‡Šæ”¾å•ä¾‹æ¨¡å¼çš„æ—¶å€™è°ƒç”¨
    static void deleteSingle();

    // æ‰“å°å•ä¾‹åœ°å€
    void Print();

 private:
    SingleInstance();
    ~SingleInstance();

    SingleInstance(const SingleInstance& single);
    const SingleInstance& operator=(const SingleInstance& single);

    static SingleInstance *m_SingleInstance_;
};


// è¿›è¡Œåˆå§‹åŒ–
SingleInstance* SingleInstance::m_SingleInstance_ = nullptr;

SingleInstance* SingleInstance::GetInstance() {
    if (m_SingleInstance_ == nullptr) {
        m_SingleInstance_ = new SingleInstance();
    }
    return m_SingleInstance_;
}


void SingleInstance::deleteSingle() {
    if (m_SingleInstance_) {
        delete m_SingleInstance_;
        m_SingleInstance_ = nullptr;
    }
}


```

### åŒé”æ£€æµ‹çš„å•ä¾‹æ¨¡å¼
```cpp

class Singleton {
 private:
    Singleton();
    ~Singleton();
 public:
    static Singleton& GetInstance() {
        if (m_instance_ == nullptr) {
            std::unique_lock lock(m);
            
        }
    }

 private:
    static Singleton* m_instance_;
    static std::mutex m;
};


```


### ä½¿ç”¨`local static`å˜é‡è¿›è¡Œä¼˜é›…çš„è®¾ç½®å•ä¾‹æ¨¡å¼
C++11è§„å®šäº†local staticåœ¨å¤šçº¿ç¨‹æ¡ä»¶ä¸‹çš„åˆå§‹åŒ–è¡Œä¸ºï¼Œè¦æ±‚ç¼–è¯‘å™¨ä¿è¯äº†å†…éƒ¨é™æ€å˜é‡çš„çº¿ç¨‹å®‰å…¨æ€§ã€‚åœ¨C++11æ ‡å‡†ä¸‹ï¼Œã€ŠEffective C++ã€‹æå‡ºäº†ä¸€ç§æ›´ä¼˜é›…çš„å•ä¾‹æ¨¡å¼å®ç°ï¼Œä½¿ç”¨å‡½æ•°å†…çš„local staticå¯¹è±¡ã€‚è¿™æ ·ï¼Œåªæœ‰å½“ç¬¬ä¸€æ¬¡è®¿é—®getInstance()æ–¹æ³•æ—¶æ‰åˆ›å»ºå®ä¾‹ã€‚
```cpp
class Singleton;

class Singleton {
 private:
    Singleton();
    Singleton(const Singleton& );
 
 public:
    static Singleton& GetInstance() {
        // ä½¿ç”¨å±€éƒ¨é™æ€å˜é‡ä¿è¯å®‰å…¨
        static Singleton instance;
        return instance;
    }


 private:
    // class member

};
```


### SkipListï¼ˆè·³è¡¨çš„å®ç°ï¼‰
```cpp

#ifndef SKIPLIST_H
#define SKIPLIST_H

#include <ctime>
#include <initializer_list>
#include <iostream>
#include <random>

template <typename Key>
class Skiplist {
public:
  struct Node {
    Node(Key k) : key(k) {}
    Key key;
    Node* next[1];  // Cè¯­è¨€ä¸­çš„æŸ”æ€§æ•°ç»„æŠ€å·§
  };

private:
  int maxLevel;
  Node* head;

  enum { kMaxLevel = 12 };

public:
  Skiplist() : maxLevel(1)
  {
    head = newNode(0, kMaxLevel);
  }

  Skiplist(std::initializer_list<Key> init) : Skiplist()
  {
    for (const Key& k : init)
    {
      insert(k);
    }
  }

  ~Skiplist()
  {
    Node* pNode = head;
    Node* delNode;
    while (nullptr != pNode)
    {
      delNode = pNode;
      pNode = pNode->next[0];
      free(delNode);  // å¯¹åº”malloc
    }
  }

  // ç¦æ­¢æ‹·è´æ„é€ å’Œèµ‹å€¼
  Skiplist(const Skiplist&) = delete;
  Skiplist& operator=(const Skiplist&) = delete;
  Skiplist& operator=(Skiplist&&) = delete;

private:
  Node* newNode(const Key& key, int level)
  {
    /*
    * å¼€è¾Ÿsizeof(Node) + sizeof(Node*) * (level - 1)å¤§å°çš„ç©ºé—´
    * sizeof(Node*) * (level - 1)å¤§å°çš„ç©ºé—´æ˜¯ç»™Node.next[1]æŒ‡é’ˆæ•°ç»„ç”¨çš„
    * ä¸ºä»€ä¹ˆæ˜¯level-1è€Œä¸æ˜¯levelï¼Œå› ä¸ºsizeof(Node)å·²åŒ…å«ä¸€ä¸ªNode*æŒ‡é’ˆçš„ç©ºé—´
    */ 
    void* node_memory = malloc(sizeof(Node) + sizeof(Node*) * (level - 1));
    Node* node = new (node_memory) Node(key);
    for (int i = 0; i < level; ++i)
      node->next[i] = nullptr;

    return node;
  }
  /*
  * éšæœºå‡½æ•°ï¼ŒèŒƒå›´[1, kMaxLevel]ï¼Œè¶Šå°æ¦‚ç‡è¶Šå¤§
  */ 
  static int randomLevel()
  {
    int level = 1;
    while (rand() % 2 && level < kMaxLevel)
      level++;

    return level;
  }

public:
  Node* find(const Key& key)
  {
    // ä»æœ€é«˜å±‚å¼€å§‹æŸ¥æ‰¾ï¼Œæ¯å±‚æŸ¥æ‰¾æœ€åä¸€ä¸ªå°äºkeyçš„å‰ç»§èŠ‚ç‚¹ï¼Œä¸æ–­ç¼©å°èŒƒå›´
    Node* pNode = head;
    for (int i = maxLevel - 1; i >= 0; --i)
    {
      while (pNode->next[i] != nullptr && pNode->next[i]->key < key)
      {
        pNode = pNode->next[i];
      }
    }

    // å¦‚æœç¬¬ä¸€å±‚çš„pNode[0]->key == keyï¼Œåˆ™è¿”å›pNode->next[0]ï¼Œå³æ‰¾åˆ°key
    if (nullptr != pNode->next[0] && pNode->next[0]->key == key)
      return pNode->next[0];

    return nullptr;
  }

  void insert(const Key& key)
  {
    int level = randomLevel();
    Node* new_node = newNode(key, level);
    Node* prev[kMaxLevel];
    Node* pNode = head;
    // ä»æœ€é«˜å±‚å¼€å§‹æŸ¥æ‰¾ï¼Œæ¯å±‚æŸ¥æ‰¾æœ€åä¸€ä¸ªå°äºkeyçš„å‰ç»§èŠ‚ç‚¹
    for (int i = level - 1; i >= 0; --i)
    {
      while (pNode->next[i] != nullptr && pNode->next[i]->key < key)
      {
        pNode = pNode->next[i];
      }
      prev[i] = pNode;
    }
    // ç„¶åæ¯å±‚å°†æ–°èŠ‚ç‚¹æ’å…¥åˆ°å‰ç»§èŠ‚ç‚¹åé¢
    for (int i = 0; i < level; ++i)
    {
      new_node->next[i] = prev[i]->next[i];
      prev[i]->next[i] = new_node;
    }

    if (maxLevel < level)  // å±‚æ•°å¤§äºæœ€å¤§å±‚æ•°ï¼Œæ›´æ–°æœ€å¤§å±‚æ•°
      maxLevel = level;
  }

  void erase(const Key& key)
  {
    Node* prev[maxLevel];
    Node* pNode = head;
    // ä»æœ€é«˜å±‚å¼€å§‹æŸ¥æ‰¾ï¼Œæ¯å±‚æŸ¥æ‰¾æœ€åä¸€ä¸ªå°äºkeyçš„å‰ç»§èŠ‚ç‚¹
    for (int i = maxLevel - 1; i >= 0; --i)
    {
      while (pNode->next[i] != nullptr && pNode->next[i]->key < key)
        pNode = pNode->next[i];
      prev[i] = pNode;
    }
    
    // å¦‚æœæ‰¾åˆ°keyï¼Œ
    if (pNode->next[0] != nullptr && pNode->next[0]->key == key)
    {
      Node *delNode = pNode->next[0];
      // ä»æœ€é«˜å±‚å¼€å§‹ï¼Œå¦‚æœå½“å‰å±‚çš„nextèŠ‚ç‚¹çš„å€¼ç­‰äºkeyï¼Œåˆ™åˆ é™¤nextèŠ‚ç‚¹
      for (int i = maxLevel - 1; i >= 0; --i)
      {
        if (prev[i]->next[i] != nullptr && key == prev[i]->next[i]->key)
          prev[i]->next[i] = prev[i]->next[i]->next[i];
      }
      free(delNode);  // æœ€åé”€æ¯pNode->next[0]èŠ‚ç‚¹
    }
    
    // å¦‚æœmax_level>1ä¸”å¤´ç»“ç‚¹çš„nextæŒ‡é’ˆä¸ºç©ºï¼Œåˆ™è¯¥å±‚å·²æ— æ•°æ®ï¼Œmax_levelå‡ä¸€
    while (maxLevel > 1 && head->next[maxLevel] == nullptr)
    {
      maxLevel--;
    }
  }
};

#endif

```



### shared_ptr & weak_ptrå¤šçº¿ç¨‹å…±äº«å¯¹è±¡é—®é¢˜
[è¿™é‡Œæ˜¯é“¾æ¥ğŸ”—ï¼Œè‡ªå·±è¦æ•²ä¸€æ•²çœ‹çœ‹](https://github.com/davidditao/DDmuduo/blob/master/C%2B%2B/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88.md#62-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%BF%E9%97%AE%E5%85%B1%E4%BA%AB%E5%AF%B9%E8%B1%A1%E9%97%AE%E9%A2%98)


## **static å’Œconståˆ†åˆ«æ€ä¹ˆç”¨ï¼Œç±»é‡Œé¢staticå’Œconstå¯ä»¥åŒæ—¶ä¿®é¥°æˆå‘˜å‡½æ•°å—**

- **static**

  - staticå¯¹äºå˜é‡

    1. å±€éƒ¨å˜é‡

       åœ¨å±€éƒ¨å˜é‡ä¹‹å‰åŠ ä¸Šå…³é”®å­—staticï¼Œå±€éƒ¨å˜é‡å°±è¢«å®šä¹‰æˆä¸ºä¸€ä¸ªå±€éƒ¨é™æ€å˜é‡ã€‚

       å†…å­˜ä¸­çš„ä½ç½®ï¼šdataæ®µ

       åˆå§‹åŒ–ï¼šå±€éƒ¨çš„é™æ€å˜é‡åªèƒ½è¢«åˆå§‹åŒ–ä¸€æ¬¡

       ä½œç”¨åŸŸï¼šä½œç”¨åŸŸä»ä¸ºå±€éƒ¨ä½œç”¨åŸŸï¼Œå½“å®šä¹‰å®ƒçš„å‡½æ•°æˆ–è€…è¯­å¥å—ç»“æŸçš„æ—¶å€™ï¼Œä½œç”¨åŸŸéšä¹‹ç»“æŸã€‚

       > å½“staticç”¨æ¥ä¿®é¥°å±€éƒ¨å˜é‡çš„æ—¶å€™ï¼Œå®ƒå°±**æ”¹å˜äº†å±€éƒ¨å˜é‡çš„å­˜å‚¨ä½ç½®ï¼ˆä»åŸæ¥çš„æ ˆä¸­å­˜æ”¾æ”¹ä¸ºé™æ€å­˜å‚¨åŒºï¼‰åŠå…¶ç”Ÿå‘½å‘¨æœŸï¼ˆå±€éƒ¨é™æ€å˜é‡åœ¨ç¦»å¼€ä½œç”¨åŸŸä¹‹åï¼Œå¹¶æ²¡æœ‰è¢«é”€æ¯ï¼Œè€Œæ˜¯ä»ç„¶é©»ç•™åœ¨å†…å­˜å½“ä¸­ï¼Œç›´åˆ°ç¨‹åºç»“æŸï¼Œåªä¸è¿‡æˆ‘ä»¬ä¸èƒ½å†å¯¹ä»–è¿›è¡Œè®¿é—®ï¼‰ï¼Œä½†æœªæ”¹å˜å…¶ä½œç”¨åŸŸã€‚**

    2. å…¨å±€å˜é‡

       åœ¨å…¨å±€å˜é‡ä¹‹å‰åŠ ä¸Šå…³é”®å­—staticï¼Œå…¨å±€å˜é‡å°±è¢«å®šä¹‰æˆä¸ºä¸€ä¸ªå…¨å±€é™æ€å˜é‡ã€‚

       å†…å­˜ä¸­çš„ä½ç½®ï¼šé™æ€å­˜å‚¨åŒºï¼ˆé™æ€å­˜å‚¨åŒºåœ¨æ•´ä¸ªç¨‹åºè¿è¡ŒæœŸé—´éƒ½å­˜åœ¨ï¼‰

       åˆå§‹åŒ–ï¼šæœªç»åˆå§‹åŒ–çš„å…¨å±€é™æ€å˜é‡ä¼šè¢«ç¨‹åºè‡ªåŠ¨åˆå§‹åŒ–ä¸º0

       ä½œç”¨åŸŸï¼šå…¨å±€é™æ€å˜é‡åœ¨å£°æ˜ä»–çš„æ–‡ä»¶ä¹‹å¤–æ˜¯ä¸å¯è§çš„ã€‚å‡†ç¡®åœ°è®²ä»å®šä¹‰ä¹‹å¤„å¼€å§‹åˆ°æ–‡ä»¶ç»“å°¾ã€‚(åªèƒ½åœ¨æœ¬æ–‡ä»¶ä¸­å­˜åœ¨å’Œä½¿ç”¨)

       > å…¨å±€å˜é‡æœ¬èº«å°±æ˜¯é™æ€å­˜å‚¨æ–¹å¼ï¼Œ é™æ€å…¨å±€å˜é‡å½“ç„¶ä¹Ÿæ˜¯é™æ€å­˜å‚¨æ–¹å¼ã€‚ä¸¤è€…çš„åŒºåˆ«åœ¨äºéé™æ€å…¨å±€å˜é‡çš„ä½œç”¨åŸŸæ˜¯æ•´ä¸ªæºç¨‹åºï¼Œ å½“ä¸€ä¸ªæºç¨‹åºç”±å¤šä¸ªæºæ–‡ä»¶ç»„æˆæ—¶ï¼Œéé™æ€çš„å…¨å±€å˜é‡åœ¨å„ä¸ªæºæ–‡ä»¶ä¸­éƒ½æ˜¯æœ‰æ•ˆçš„ï¼ˆåœ¨å…¶ä»–æºæ–‡ä»¶ä¸­ä½¿ç”¨æ—¶åŠ ä¸Šexternå…³é”®å­—é‡æ–°å£°æ˜å³å¯ï¼‰ã€‚ è€Œ**é™æ€å…¨å±€å˜é‡åˆ™é™åˆ¶äº†å…¶ä½œç”¨åŸŸï¼Œ å³åªåœ¨å®šä¹‰è¯¥å˜é‡çš„æºæ–‡ä»¶å†…æœ‰æ•ˆï¼Œ åœ¨åŒä¸€æºç¨‹åºçš„å…¶å®ƒæºæ–‡ä»¶ä¸­ä¸èƒ½ä½¿ç”¨å®ƒ**ã€‚

  - staticå¯¹äºå‡½æ•°

    ä¿®é¥°æ™®é€šå‡½æ•°ï¼Œè¡¨æ˜å‡½æ•°çš„ä½œç”¨èŒƒå›´ï¼Œä»…åœ¨å®šä¹‰è¯¥å‡½æ•°çš„æ–‡ä»¶å†…æ‰èƒ½ä½¿ç”¨ã€‚åœ¨å¤šäººå¼€å‘é¡¹ç›®æ—¶ï¼Œä¸ºäº†é˜²æ­¢ä¸ä»–äººå‘½åç©ºé—´é‡Œçš„å‡½æ•°é‡åï¼Œå¯ä»¥å°†å‡½æ•°å®šä½ä¸º staticã€‚ï¼ˆå’Œå…¨å±€å˜é‡ä¸€æ ·é™åˆ¶äº†ä½œç”¨åŸŸè€Œå·²ï¼‰

  - staticå¯¹äºç±»

    1. æˆå‘˜å˜é‡

       ç”¨staticä¿®é¥°ç±»çš„æ•°æ®æˆå‘˜å®é™…ä½¿å…¶æˆä¸ºç±»çš„å…¨å±€å˜é‡ï¼Œä¼šè¢«ç±»çš„æ‰€æœ‰å¯¹è±¡å…±äº«ï¼ŒåŒ…æ‹¬æ´¾ç”Ÿç±»çš„å¯¹è±¡ã€‚

       å› æ­¤ï¼Œ**staticæˆå‘˜å¿…é¡»åœ¨ç±»å¤–è¿›è¡Œåˆå§‹åŒ–ï¼Œè€Œä¸èƒ½åœ¨æ„é€ å‡½æ•°å†…è¿›è¡Œåˆå§‹åŒ–ã€‚ä¸è¿‡ä¹Ÿå¯ä»¥ç”¨constä¿®é¥°staticæ•°æ®æˆå‘˜åœ¨ç±»å†…åˆå§‹åŒ– ã€‚**

    2. æˆå‘˜å‡½æ•°

       ç”¨staticä¿®é¥°æˆå‘˜å‡½æ•°ï¼Œä½¿è¿™ä¸ªç±»åªå­˜åœ¨è¿™ä¸€ä»½å‡½æ•°ï¼Œæ‰€æœ‰å¯¹è±¡å…±äº«è¯¥å‡½æ•°ï¼Œä¸å«thisæŒ‡é’ˆã€‚

       *** é™æ€æˆå‘˜æ˜¯å¯ä»¥ç‹¬ç«‹è®¿é—®çš„ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œæ— é¡»åˆ›å»ºä»»ä½•å¯¹è±¡å®ä¾‹å°±å¯ä»¥è®¿é—®ã€‚ ***  è¿™ä¸ªåœ¨é¡¹ç›®ä¸­çš„TimeStampçš„now()å‡½æ•°ç”¨åˆ°

       **ä¸å¯ä»¥åŒæ—¶ç”¨constå’Œstaticä¿®é¥°æˆå‘˜å‡½æ•°ã€‚**

- **const**

  1. constä¿®é¥°å˜é‡ï¼šé™å®šå˜é‡ä¸ºä¸å¯ä¿®æ”¹ã€‚

  2. constä¿®é¥°æŒ‡é’ˆï¼šæŒ‡é’ˆå¸¸é‡å’ŒæŒ‡å‘å¸¸é‡çš„æŒ‡é’ˆ

  3. constå’Œå‡½æ•°ï¼šæœ‰ä»¥ä¸‹å‡ ç§å½¢å¼

     ```
     const int& fun(int& a); //ä¿®é¥°è¿”å›å€¼
     int& fun(const int& a); //ä¿®é¥°å½¢å‚
     int& fun(int& a) const{} //constæˆå‘˜å‡½æ•°
     ```

  4. constå’Œç±»ï¼šâ‘ constä¿®é¥°æˆå‘˜å˜é‡ï¼Œåœ¨æŸä¸ªå¯¹è±¡çš„å£°æ˜å‘¨æœŸå†…æ˜¯å¸¸é‡ï¼Œä½†æ˜¯å¯¹äºæ•´ä¸ªç±»è€Œè¨€æ˜¯å¯ä»¥æ”¹å˜çš„ã€‚å› ä¸ºç±»å¯ä»¥åˆ›å»ºå¤šä¸ªå¯¹è±¡ï¼Œä¸åŒçš„å¯¹è±¡å…¶constæˆå‘˜å˜é‡çš„å€¼æ˜¯ä¸åŒçš„ã€‚åˆ‡è®°ï¼Œ**ä¸èƒ½åœ¨ç±»å†…åˆå§‹åŒ–constæˆå‘˜å˜é‡**ï¼Œå› ä¸ºç±»çš„å¯¹è±¡æ²¡åˆ›å»ºå‰ï¼Œç¼–è¯‘å™¨å¹¶ä¸çŸ¥é“constæˆå‘˜å˜é‡æ˜¯ä»€ä¹ˆï¼Œå› æ­¤constæ•°æ®æˆå‘˜åªèƒ½åœ¨åˆå§‹åŒ–åˆ—è¡¨ä¸­åˆå§‹åŒ–ã€‚â‘¡constä¿®é¥°æˆå‘˜å‡½æ•°ï¼Œä¸»è¦ç›®çš„æ˜¯é˜²æ­¢æˆå‘˜å‡½æ•°ä¿®æ”¹æˆå‘˜å˜é‡çš„å€¼ï¼Œå³è¯¥æˆå‘˜å‡½æ•°å¹¶ä¸èƒ½ä¿®æ”¹æˆå‘˜å˜é‡ã€‚â‘¢constå¯¹è±¡ï¼Œå¸¸å¯¹è±¡ï¼Œå¸¸å¯¹è±¡åªèƒ½è°ƒç”¨å¸¸å‡½æ•°ã€‚

  5. é™å®šæˆå‘˜å‡½æ•°ä¸å¯ä»¥ä¿®æ”¹ä»»ä½•æ•°æ®æˆå‘˜

- staticå’Œconstå¯ä»¥åŒæ—¶ä¿®é¥°æˆå‘˜å‡½æ•°å—?

  ç­”ï¼šä¸å¯ä»¥ã€‚C++ç¼–è¯‘å™¨åœ¨å®ç°constçš„æˆå‘˜å‡½æ•°çš„æ—¶å€™ä¸ºäº†ç¡®ä¿è¯¥å‡½æ•°ä¸èƒ½ä¿®æ”¹ç±»çš„å®ä¾‹çš„çŠ¶æ€ï¼Œä¼šåœ¨å‡½æ•°ä¸­æ·»åŠ ä¸€ä¸ªéšå¼çš„å‚æ•°const this*ã€‚ä½†å½“ä¸€ä¸ªæˆå‘˜ä¸ºstaticçš„æ—¶å€™ï¼Œè¯¥å‡½æ•°æ˜¯æ²¡æœ‰thisæŒ‡é’ˆçš„ã€‚ä¹Ÿå°±æ˜¯è¯´æ­¤æ—¶constçš„ç”¨æ³•å’Œstaticæ˜¯å†²çªçš„ã€‚ä¸¤è€…çš„è¯­æ„æ˜¯çŸ›ç›¾çš„ã€‚**staticçš„ä½œç”¨æ˜¯è¡¨ç¤ºè¯¥å‡½æ•°åªä½œç”¨åœ¨ç±»å‹çš„é™æ€å˜é‡ä¸Šï¼Œä¸ç±»çš„å®ä¾‹æ²¡æœ‰å…³ç³»ï¼›è€Œconstçš„ä½œç”¨æ˜¯ç¡®ä¿å‡½æ•°ä¸èƒ½ä¿®æ”¹ç±»çš„å®ä¾‹çš„çŠ¶æ€**ï¼Œä¸ç±»å‹çš„é™æ€å˜é‡æ²¡æœ‰å…³ç³»ã€‚å› æ­¤ä¸èƒ½åŒæ—¶ç”¨å®ƒä»¬ã€‚

## 


## æ‰‹æ’•çš„æ•°æ®ç»“æ„&æ¨¡å‹ç­‰


### å“ˆå¸Œè¡¨
[è¿™é‡Œæ˜¯é“¾æ¥ğŸ”—](https://zhuanlan.zhihu.com/p/144296454)


### å†’æ³¡æ’åº

```cpp

void Bubble_Sort(int a[], int length) {
    for (int i = 0; i < length; i++) {
        for (int j = 0; j < len - i - 1; j++) {
            if (a[j] > a[j+1]) {
                swap(a[j], a[j+1]);
            }
        } 
    }
}


```



#### å¿«é€Ÿæ’åº
```cpp

void quickSort(int left, int right, vector<int>& arr) {
    if (left >= right) return ;
    int i, j, base = arr[left];
    i = left, j = right;

    while (i < j) {
        // æ‰¾å°äºåŸºæ•°çš„ä½ç½®
        while (arr[j] >= base && i < j)  j--;
        while (arr[i] <= base && i < j)  i++;
        if (i < j) swap(arr[i], arr[j]);
    }

    swap(arr[i], arr[left]);            // äº¤æ¢base ä¸ äº¤æ±‡ç‚¹
    quickSort(left, i-1, arr);
    quickSort(i+1, right, arr);
}

```


#### å †æ’åº
> - è¿­ä»£è°ƒæ•´æœ€å¤§å †
> - äº¤æ¢å †é¡¶åˆ°æœ«å°¾å®ç°æ’åºï¼Œäº¤æ¢åè°ƒæ•´å †çš„ç»“æ„
```cpp
#include <iostream>
using namespace std;


// é€’å½’è¿›è¡Œå¤§é¡¶å †çš„è°ƒæ•´
void adjust(int a[], int len, int index) {
    int left  = index * 2 + 1;
    int right = index * 2 + 2;

    int maxIdx = index;
    if (left < len && a[left] > a[maxIdx]) maxIdx = left;
    if (right <len && a[right]> a[maxIdx]) maxIdx = right;
    
    if (maxIdx != index) {
        swap(a[maxIdx], a[index]);     // å°†æ¯”è¾ƒå¤§çš„æ•°äº¤æ¢ä¸Šå»
        // å¦‚æœæœ‰å­èŠ‚ç‚¹çš„è¯ç»§ç»­è¿›è¡Œæ’åº
        adjust(a, len, maxIdx);
    }
}


void heapSort(int a[], int size) {
    // ä»æœ€åä¸€ä¸ªéå¶å­ç»“ç‚¹è¿›è¡Œå¤§é¡¶å †çš„æ„é€ 
    for (int i = size / 2 - 1; i >= 0; i--) {
        adjust(a, size, i);
    }

    // å°†é¡¶ä¸Šé¢çš„æ•°æ®äº¤æ¢åˆ°åº•éƒ¨
    for (int i = size - 1; i > 0; i--) {
        swap(a[i], a[0]);
        adjust(a, i, 0);
    }
}
    

int main() {
    int a[10] = { 21, 343, 122, 84, 5, 117, 4, 35, 90, 666 };
    int size = 10;
    heapSort(a, size);

    for (int i = 0; i < size; i++) {
        cout << a[i] << " ";
    }
    return 0;
}
```


### MergeSort
> - é€’å½’çš„å°†æ•°ç»„åˆ†æˆå·¦å³å­æ•°æ®ï¼Œè¿”å›æ—¶æ˜¯æœ‰åºçš„
> - å°†ä¸¤ä¸ªåˆ†åˆ«æœ‰åºçš„å­—æ•°ç»„è¿›è¡Œåˆå¹¶ï¼Œç”¨åˆ°ä¸€ä¸ªä¸´æ—¶æ•°ç»„è¿›è¡Œåˆå¹¶

```cpp
#include <iostream>
using namespace std;

int tmp[500];

void merge_Sort(int a[], int l, int r) {

    if (l >= r) return ;
    // recursionå°†æ•°ç»„åˆ†æˆä¸¤åŠ
    int mid = (l + r) >> 1;
    merge_Sort(a, l, mid), merge_Sort(a, mid+1, r);

    // ä¸‹é¢å°±æ˜¯å°†ä¸¤ä¸ªå­—æ•°ç»„è¿›è¡Œåˆå¹¶, åˆ›å»ºä¸€ä¸ªä¸´æ—¶çš„æ•°ç»„

    int k = 0, i = l, j = mid + 1;
    while (i <= mid && j <= r) {
        // å°†æ¯”è¾ƒå°(å¤§)çš„å…ƒç´ å–å‡ºæ¥æ”¾åˆ°ä¸´æ—¶æ•°ç»„
        if (a[i] < a[j])
            tmp[k++] = a[i++];
        else 
            tmp[k++] = a[j++];
    }

    // å¦‚æœè¿˜æœ‰å…ƒç´ æ²¡æœ‰å–å‡ºæ¥ï¼Œå°†å‰©ä½™çš„æ”¾åˆ°ä¸´æ—¶æ•°ç»„ï¼Œ   
    while (i <= mid) 
        tmp[k++] = a[i++];
    while (j <= r)
        tmp[k++] = a[j++];

    // è¿›è¡Œèµ‹å€¼
    for (int i = l, j = 0; i <= r; i++, j++) {
        a[i] = tmp[j];
    }

}

int main() {
    int a[10] = { 21, 343, 122, 84, 5, 117, 4, 35, 90, 666 };
    int size = 10;
    printf("Merge sort\n");
    merge_Sort(a, 0, size - 1);

    for (int i = 0; i < size; i++) {
        cout << a[i] << " ";
    }
    return 0;
}

```

### ç®€å•å¼•ç”¨è®¡æ•°å…±äº«æŒ‡é’ˆ

```cpp

template<class T>

class Ref_count {
 
 public:
    Ref_count(T *t)
        : ptr_(t), count_(new int(1)) {}

    ~Ref_count() {
        decrease();
    }

    Ref_count(const Ref_count<T>& tmp) {
        // è¿›è¡Œæ‹·è´æ„é€ , æŒ‡å‘ç›¸åŒçš„å†…å®¹
        count_ = tmp->count_;
        ptr_   = tmp->ptr_;
        increase();
    }

    Ref_count<T>& operator=(const Ref_count& tmp) {
        // å·¦è¾¹çš„æ”¾å¼ƒï¼Œå³è¾¹çš„+1
        if (tmp != this) {
            decrease();             // å·¦è¾¹çš„è¢«decrease();
            ptr_    = tmp->ptr_;
            count_  = tmp->count_;
            increase();             // å³è¾¹çš„å¯¹åº”çš„å¼•ç”¨è®¡æ•°åŠ ä¸€
        }
        return *this;
    }

    void increase() {
        if (count_) {
            *(count_)++;
        }
    }

    T* operator->() const {
        return ptr_;
    }

    T& operator*() const {
        return *ptr_;
    }

    void decrease() {
        if (count_) {
            *(count_)--;
            if (*count_ == 0) {
                // å¼•ç”¨è®¡æ•°ä¸º0ï¼Œé‡Šæ”¾
                delete count_; count_ = nullptr;
                delete ptr_;   ptr_   = nullptr;
            }
        }
    }

    T* get() const {        // get raw pointer 
        return ptr_;
    }

    int get_count() const {
        if (!count_) return 0;
        return *count_;
    }
 private:
    T* ptr_;                // raw pointer
    int* count_;            // ref count

};

```

### åè½¬é“¾è¡¨
```cpp

class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* prev = nullptr;
        ListNode* cur  = head;


        // a -> b -> c
        while (cur) {
            ListNode* next = cur->next;
            cur->next = prev;
            prev = cur;
            cur = next;
        }
        return prev;
    }
};

```

### é€’å½’åè½¬é“¾è¡¨

```cpp
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if (!head || !head->next) {
            return head;
        }
        ListNode* newHead = reverseList(head->next);
        head->next->next = head;
        head->next = nullptr;
        return newHead;
    }
};
```



### äºŒå‰æ ‘å…ˆåºéå† 1.è¿­ä»£
> - ç”¨æ ˆè¿›è¡Œå­˜æ”¾ï¼Œå…ˆæ”¾å³è¾¹çš„æ‰èƒ½ä¿éšœå·¦è¾¹çš„å…ˆå‡ºæ¥

```cpp

class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> result;
        stack<TreeNode*> st;
        st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();
            st.pop();
            result.push_back(node->val);            // ä¸­
            if (node->right) st.push(node->right);
            if (node->left)  st.push(node->left);
        }
        return result;
    }
};

```

### äºŒå‰æ ‘å…ˆåºéå†ï¼ˆéƒ­éƒ­æ€è·¯ï¼‰
>  æ¨¡æ‹Ÿä¸€ä¸ªèŠ‚ç‚¹èµ°çš„è·¯å¾„çš„æ€è·¯ï¼Œæ ¸å¿ƒä»£ç éƒ½æ˜¯ç›¸åŒçš„
```cpp

class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> res;
        stack<TreeNode*>st;
        Treenode* node = root;
        while (node || stack.size()) {
            // å°½å¯èƒ½å‘å·¦ï¼Œæ ¹å·¦å³
            while (node) {
                res.push_back(node->val);
                st.push(node);
                node = node->left;
            }
            // éå†åˆ°æœ€å·¦è¾¹äº†ï¼Œå¼¹æ ˆï¼Œå‘å³
            TreeNode* cur = st.top(); st.pop();
            node = cur->right;
        }
        return res;   
    }
};

```


### äºŒå‰æ ‘ååºéå† ï¼ˆéƒ­éƒ­æ€è·¯ï¼‰
> - æ ¹å³å·¦çš„reverseç‰ˆæœ¬ï¼Œä½†æ˜¯ä¸èƒ½è¾¹éå†è¾¹å¤„ç†ï¼Œä½†æ˜¯èƒ½å¤Ÿç®€åŒ–æ€è·¯ï¼Œ åŒä¸Šé¢ç±»ä¼¼


### äºŒå‰æ ‘ä¸­åºéå† ï¼ˆéƒ­éƒ­æ€è·¯ï¼‰

>  ä¸­åºéå†ä¹Ÿæ˜¯å…ˆå‘å·¦ï¼Œä½†æ˜¯æ ¹ç»“ç‚¹æ˜¯å¼¹æ ˆçš„æ—¶å€™æ‰åŠ å…¥åˆ°resçš„
```cpp

class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> res;
        stack<TreeNode*>st;
        Treenode* node = root;
        while (node || st.size()) {
            // ä¸æ–­çš„å‘å·¦èµ°
            while (node) {
                st.push(node);
                node = node->left;
            }
            node = st.top(); st.pop();
            res.push_back(node->val);
            root = root->right;
        }
    }
};

```

### Memcpyçš„å®ç°ï¼Œ
> ä¸åŒäºstrcpy, è¿™æ˜¯å†…å­˜çº§åˆ«çš„æ‹·è´ï¼Œåè€…åªæ˜¯å­—ç¬¦ä¸²çš„æ‹·è´
> éœ€è¦è€ƒè™‘çš„ç‚¹å°±æ˜¯æ˜¯å¦æ˜¯æœ‰å†…å­˜çš„é‡å çš„æƒ…å†µï¼Œåªéœ€è¦åˆ¤æ–­ä¸‹é¢è¿™ç§æƒ…å†µå°±è¡Œ

> `111111111`   src
>      `000000000`  dst
> å› ä¸ºå†…å­˜æ˜¯é‡å çš„ï¼Œæ‰€ä»¥dstç›´æ¥å°†srcåé¢çš„è¦†ç›–æ‰äº†ï¼Œæ²¡äº†ã€‚ã€‚ã€‚è§£å†³åŠæ³•å°±æ˜¯ä»åå¾€å‰å¤åˆ¶


```cpp

void* my_memcpy(void* dst, const void* src, size_t count) {
    if (dst == nullptr || src == nullptr)   return nullptr;
    char* tmp_dst = (char*)dst;
    char* tmp_src = (char*)src;
    if (tmp_dst > tmp_src && tmp_dst < tmp_src + count) {
        // æœ‰å†…å­˜çš„é‡å 
        tmp_dst = tmp_dst + count - 1;
        tmp_src = tmp_src + count - 1;
        while (count --) {
            *tmp_dst-- = *tmp_src--;
        }
    } else {
        while (count--) {
            *tmp_dst++ = *tmp_src++;
        }
    }
    return (void*)dst;
}

```


### æ­»é”çš„æ£€æµ‹
> - ä½¿ç”¨pstack <pid> èƒ½å¤ŸæŸ¥çœ‹æ ˆå¸§çš„è°ƒç”¨æƒ…å†µ
> - GDB ä½¿ç”¨`info threads` æŸ¥çœ‹çº¿ç¨‹ï¼Œ`thread 2`åˆ‡æ¢çº¿ç¨‹ï¼Œ`bt`æ‰“å°çº¿ç¨‹çš„è°ƒç”¨æ ˆä¿¡æ¯ï¼Œ`print`å…·ä½“æŸ¥çœ‹å˜é‡çš„å€¼

** æµ‹è¯•ä»£ç  **

```cpp
#include <stdio.h>
#include <pthread.h>
#include <unistd.h>

pthread_mutex_t mutex_A = PTHREAD_MUTEX_INITIALIZER;
pthread_mutex_t mutex_B = PTHREAD_MUTEX_INITIALIZER;


void *threadB_proc(void *data)
{
    printf("thread B waiting get ResourceB \n");
    pthread_mutex_lock(&mutex_B);
    printf("thread B got ResourceB \n");
    
    sleep(1);
    
    printf("thread B waiting  get ResourceA \n");
    pthread_mutex_lock(&mutex_A);
    printf("thread B got ResourceA \n");
    
    pthread_mutex_unlock(&mutex_A);
    pthread_mutex_unlock(&mutex_B);
    return (void *)0;
}


//çº¿ç¨‹å‡½æ•° A
void *threadA_proc(void *data)
{
    printf("thread A waiting get ResourceA \n");
    pthread_mutex_lock(&mutex_A);
    printf("thread A got ResourceA \n");
    
    sleep(1);
    
    printf("thread A waiting get ResourceB \n");
    pthread_mutex_lock(&mutex_B);
    printf("thread A got ResourceB \n");

    pthread_mutex_unlock(&mutex_B);
    pthread_mutex_unlock(&mutex_A);
    return (void *)0;
}


int main() {
    pthread_t tidA, tidB;

    pthread_create(&tidA, NULL, threadA_proc, NULL);
    pthread_create(&tidB, NULL, threadB_proc, NULL);
    
    pthread_join(tidA, NULL);
    pthread_join(tidB, NULL);
    
    printf("exit\n");
    
    return 0;
}


```



